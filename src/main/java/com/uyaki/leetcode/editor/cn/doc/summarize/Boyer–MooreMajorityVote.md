# 摩尔投票法

- [摩尔投票法](#摩尔投票法)
  - [原理](#原理)
  - [伪代码](#伪代码)
  - [扩展](#扩展)
  - [应用](#应用)

## 原理

> 摩尔投票法的核心思想为对拼消耗。

> 分为两个阶段
> 1. 抵消阶段：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数；
> 2. 计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。

首先我们考虑最基本的摩尔投票问题。

比如找出一组数字序列中出现次数大于总数 `1/2`的数字（并且假设这个数字一定存在）。

- 在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。
- 这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。
- 如果只存在一种元素，那么这个元素则可能为目标元素。

那么有没有可能出现最后有两种或两种以上元素呢？

- 根据定义，这是不可能的，因为如果出现这种情况，则代表我们可以继续一轮投票。
- 因此，最终只能是剩下零个或一个元素

## 伪代码

```text
初始化元素m并给计数器i赋初值i = 0
对于输入队列中每一个元素x：
- 若i = 0, 那么 m = x and i = 1
- 否则若m = x, 那么 i = i + 1
- 否则 i = i − 1
- 返回 m
```

- 即便输入序列没有多数元素，这一算法也会返回一个序列元素。
- 如果能够进行第二轮遍历，**检验返回元素的出现次数**，就能判断返回元素是否为多数元素。因此算法需要两次遍历

## 扩展

找出一组数字序列中出现次数大于总数 `1/3`的数字（并且假设数字一定存在）

## 应用

|难度|题目|题解|掌握度|
|:---:|:---|:---|:---:|
|🧡 |[P229_求众数 II](./../content/P229_MajorityElementIi.md) |[P229_MajorityElementIi.java](./../../P229_MajorityElementIi.java)|😄|